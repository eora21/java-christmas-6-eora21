# 요구사항
## 메뉴 구현
- [x] 애피타이저 메뉴를 구현한다.
	- 양송이수프(6,000)
	- 타파스(5,500)
	- 시저샐러드(8,000)
- [x] 메인 메뉴를 구현한다.
	- 티본스테이크(55,000)
	- 바비큐립(54,000)
	- 해산물파스타(35,000)
	- 크리스마스파스타(25,000)
- [x] 디저트 메뉴를 구현한다.
	- 초코케이크(15,000)
	- 아이스크림(5,000)
- [x] 음료 메뉴를 구현한다.
	- 제로콜라(3,000)
	- 레드와인(60,000)
	- 샴페인(25,000)
## 이벤트 구현
- [x] **이벤트는 총주문 금액 10,000원 이상부터 적용**되어야 한다.
- [x] 크리스마스 디데이 할인을 구현한다.
	- [x] 이벤트 기간은 **1일부터 25일까지**이다.
	- [x] **1,000원으로 시작**하여 날이 지날 때마다 **할인 금액이 100원씩 증가**한다.
	- [x] 기간 외에 활성화될 시 예외를 발생한다.
	- [x] 할인은 **총주문 금액에서 해당 금액만큼 할인**한다.
- [x] 평일 할인을 구현한다.
	- [x] 이벤트 기간은 **1일부터 31일까지**이다.
	- [x] 이벤트 요일은 **일요일부터 목요일까지**이다.
	- [x] **디저트** 메뉴 **1개당 2,023원 할인**한다.
- [x] 주말 할인을 구현한다.
	- [x] 이벤트 기간은 **1일부터 31일까지**이다.
	- [x] 이벤트 요일은 **금요일, 토요일**이다.
	- [x] **메인** 메뉴 **1개당 2,023원 할인**한다.
- [x] 특별 할인을 구현한다.
	- [x] 이벤트 기간은 **1일부터 31일까지**이다.
	- [x] 이벤트 일자는 **이벤트 달력에 별이 있는 날짜**(3일, 10일, 17일, 24일 ,25일, 31일)이다.
	- [x] 할인은 **총주문 금액에서 1,000원 할인**한다.
- [x] 증정 이벤트를 구현한다.
	- [x] **할인 전 총주문 금액**이 **120,000원 이상**일 때 음료 메뉴의 **샴페인을 증정**한다. 
## 이벤트 배지 부여
- [x] 총혜택 금액(할인 금액의 합계 + 증정 메뉴의 가격)에 따라 이벤트 배지를 부여한다.
	- [x] 5,000원 이상일 때는 별을 부여한다.
	- [x] 10,000원 이상일 때는 트리를 부여한다.
	- [x] 20,000원 이상일 때는 산타를 부여한다.
- [x] 이벤트 배지를 구현한다.
	- 별
	- 트리
	- 산타
## 주문 구현
- [x] 우테코 식당 이벤트 플래너 안내메시지를 출력한다.
- [x] 식당 방문 날짜를 입력받는다.
	- [x] 식당 방문 날짜 입력 안내메시지를 출력한다.
	- [x] 입력을 숫자로 변환해 반환한다.
		- [x] 1 이상 31 이하의 숫자가 아닌 경우 유효하지 않은 날짜 예외 메시지를 출력한다.
- [x] 주문받을 메뉴 및 개수를 입력받는다.
	- [x] 주문 메뉴 및 개수 입력 안내메시지를 출력한다.
	- [x] 입력을 구분하여 반환한다.
		- [x] 주문들은 쉼표를 기준으로 나눈다.
		- [x] 메뉴와 메뉴의 개수는 '-'를 기준으로 나눈다.
		- [x] 아무런 메뉴도 주문하지 않았을 시 예외를 발생시킨다.
		- [x] 음료만 주문 시 주문할 수 없다는 예외를 발생시킨다.
		- [x] 메뉴의 개수가 1 미만일 경우 유효하지 않은 주문 예외 메시지를 발생시킨다.
		- [x] 메뉴의 형식이 예시와 다른 경우 유효하지 않은 주문 예외 메시지를 발생시킨다.
		- [x] 중복 메뉴를 입력한 경우 유효하지 않은 주문 예외 메시지를 발생시킨다.
		- [x] 메뉴의 개수 총 합이 20개 초과일 경우 예외를 발생시킨다.
- [x] 이벤트 혜택 미리 보기를 출력한다.
	- [x] 주문 메뉴들을 출력한다.
		- [x] 출력 순서는 자유롭게 한다.
	- [x] 할인 전 총주문 금액을 출력한다.
	- [x] 증정 메뉴를 출력한다.
		- [x] 증정 이벤트에 해당하지 않는 경우, 증정 메뉴 "없음"으로 보여준다.
	- [x] 혜택 내역을 출력한다.
		- [x] 현재 주문으로 인한 고객에게 적용된 이벤트 내역만 보여준다.
		- [x] 혜택이 없는 경우 "없음"으로 보여준다.
		- [x] 출력 순서는 자유롭게 한다.
	- [x] 총혜택 금액을 출력한다.
		- [x] 총혜택 금액은 할인 금액의 합계 + 증정 메뉴의 가격이다.
	- [x] 할인 후 예상 결제 금액을 출력한다.
		- [x] 할인 후 예상 결제 금액은 할인 전 총주문 금액 - 할인 금액이다.
	- [x] 이벤트 배지를 출력한다.
		- [x] 이벤트 배지가 부여되지 않는 경우 "없음"으로 보여준다.
- [x] 모든 예외메시지 앞에는 "[ERROR]"를 출력한다.
# 필요한 기능
- [x] 입력받은 날짜를 기반으로 요일을 획득한다.
- [x] 적용될 이벤트 목록을 가져온다.
- [x] 메뉴 및 할인전 총주문 금액을 바탕으로 적용 내역을 가져온다.
	- [x] 증정 메뉴를 가져온다.
	- [x] 혜택 내역을 가져온다.
	- [x] 할인 금액을 가져온다.
---
# 고민한 사항들

## 확장 가능한 구조
해당 애플리케이션이 2023년 12월만 타겟으로 한 게 아닌, 다음에도 사용될 수 있을 거라는 생각을 했습니다. 따라서 주어진 조건들을 잘 추상화하되, 최대한 확장에 열려있는 구조를 갖추고자 노력했습니다.
## 메뉴를 어떻게 구조화할 것인가
메뉴들은 특정 그룹으로 나뉘어지고 있습니다. 해당 그룹들의 분류를 구현하되, 모든 메뉴들을 한 곳에서 접근할 방법을 모색했습니다.
이에 세가지 방법을 고민했습니다.
### Menu abstract class를 만든 후 extends
메뉴 가상 클래스에서 각각 구성에 필요한 필드를 작성 및 강제할 수 있습니다.
예로 메뉴에 이름과 가격 필드를 작성하고, 이를 생성자로 넣어주게 한다면 다른 클래스들은 이러한 형태를 무조건 따라야 하고, 각각의 필드값이 무조건 존재함을 예측할 수 있습니다. 또한 생성자 내부에 메뉴 목록 업데이트 코드를 첨부하면 모든 메뉴들의 구현체들을 자연스레 모을 수 있을 것입니다.
### Menu interface를 만든 후 각각의 enum 그룹에서 implements
메뉴 인터페이스에서 이름, 가격을 반환하게 강제합니다.
각각의 enum은 객체들을 작성하되, 내부 형태는 비교적 자유롭게 가져갈 수 있습니다. 이름과 가격에 대해 필드를 강제하지 않기 때문입니다. 다만 각각의 반환값만 제대로 맞춰주면, 내부적으로 어떤 설계를 가져간다 한들 문제될 일이 없습니다.
### Menu enum을 만들고 생성자 파라미터로 그룹 정보 제공
전체의 메뉴를 기입하고, 파라미터로 각 음식의 해당 그룹을 정의하는 방법입니다.
구현이 가장 쉽고 간편하나, 특정 변동이 생기는 경우(예: 세트메뉴 추가) 평등관계가 깨져 enum을 각각 쪼개 구현하거나, 해당 enum 객체들의 목록을 갖는 다른 클래스를 구현하거나, 아니면 enum의 필드값들을 변동시켜야 합니다. 즉, 확장성이 제일 낮습니다.

처음엔 enum과 interface의 조합을 시도하기 위해 두번째 방법을 사용하는 방향을 선택했습니다.
다만 각각의 인스턴스가 만들어질 때마다 메뉴 목록에 추가하기 위해서는 생성자에 해당 동작을 위한 메서드를 작성해야 했는데, 이를 누락할 가능성이 있었습니다. 즉, 해당 로직을 강제할 방법이 없어 보였습니다.
ServiceLoader를 사용하면 된다고는 하나 이 또한 그룹이 늘어날 경우 강제적인 관리가 필요해야 했기에 선택하지 않았습니다.

이에 첫번째 방법을 선택하였으나, enum처럼 활용하기 위해선 상속받은 클래스마다 상수 인스턴스를 지니고 있어야 했습니다. 허나 이는 해당 클래스가 로딩이 선행되어야만 인스턴스가 생성됨을 보장할 수 있습니다. 따라서 잘못하면 원치 않는 동작이 일어날 수 있었습니다. 자식 클래스를 메모리에 올리는 초기 로딩 과정이 있으면 해결되겠지만 이를 따로 구현하는 것 자체가 동작을 강제할 힘이 없음을 보이는 것이라 생각했습니다.
또한, 부모 클래스에서만 static 메서드를 동작시키고 싶어도 자식 클래스 또한 권한을 갖기에 어떤 식으로 접근해도 허용된다는 문제가 있습니다. 물론 자식 클래스로도 접근하는 게 큰 문제가 되지 않을 수 있겠지만, 최대한 코드를 깔끔하게 가져가며 오남용을 방지하고자 했습니다.

따라서 마지막 세번째 방법을 선택하여 구현하기로 하였습니다.
해당하는 방법은 확장성이 낮지만 제일 단순하면서도, 현재 고민중인 내용들을 최대한 쉽게 가져갈 수 있었습니다.

## 이벤트를 어떻게 구조화할 것인가
메뉴처럼 이벤트를 Enum으로 구조화한다면 각각을 싱글턴으로 유지할 수 있고, 목록을 가져오는 것도 손쉽게 할 수 있습니다.
다만 단점은, Enum의 책임이 너무 커질 수 있다는 점입니다.
하나의 Enum에 각각의 이벤트 구현체를 위해 특정 메서드를 작성해야 하는데, 함수형을 아무리 잘 사용한다 해도 이벤트의 수가 많아지면 많아질 수록 메서드들의 종류가 급격히 늘어날 것입니다.

현재 주어진 이벤트를 추상화해보면 다음과 같습니다.
- 이벤트의 기간을 지니고 있습니다.
- 특정 날짜를 기반으로 이벤트가 수행될 수 있는지 파악합니다.
- 내부적인 로직을 통해 이벤트를 수행합니다.
	- 메뉴 그룹과 속한 개수에 따라 할인됩니다.
	- 날짜를 기반으로 총주문 금액에서 할인됩니다.
	- 할인 전 총주문 금액을 기반으로 특정 품목이 증정됩니다.
### 증정과 할인을 통한 가능성과 다양성 유추
이벤트 중 증정은 특정 메뉴를 제공하고, 메뉴 가격만큼 혜택 내역에서 가격을 표기해야 했습니다.
다만 할인은 실제 금액에서 얼마나 차감될지를 표기해야 했습니다.
따라서 이 둘을 실질적으로 구분해야 했습니다. 물론 함수형을 잘 이용하면 문제 없이 진행될 수 있으나, 만약 여러 종류의 이벤트들이 생길 경우 Enum의 구조가 계속 바뀌거나 쪼개야 한다고 판단했습니다. 비교적 제약이 있는 메뉴보다, 훨씬 많은 가능성과 다양성을 지닌 것이 이벤트라 생각했기 때문입니다.
예로, 이벤트 배지 부여도 하나의 이벤트로 본다면 이는 Enum으로 추가 구현하기 어려워질 수 있습니다. 추상화를 다시 하여, 공통점을 다시 이끌어야 하기 때문입니다.

따라서 이번에는 Enum을 사용하지 않을 생각이었습니다.
그러나, 똑같은 고민에 봉착했습니다.
## 클래스 동적 로딩 타이밍은 어떻게 해결할 것인가
메뉴를 구성할 때와 같은 문제가 생겼습니다. 아무리 잘 구조화한다 해도, 결국 클래스가 로딩되지 않으면 동작되지 않습니다.
싱글턴으로 생성하여 이벤트 목록에 넣어두겠다! 라고 생각해도 결국 메인 스레드가 클래스의 인스턴스를 생성하거나, 정적 변수를 사용하거나, 정적 메서드를 호출하지 않으면 소용이 없는 것입니다.
즉 메인에서 해당 이벤트들을 강제로 생성 혹은 인스턴스를 얻어와 묶어주거나, 특정 메서드를 호출시켜야 한다는 것을 뜻합니다.
이는 프로그래머의 코드 강제를 뜻하고, 실수할 가능성이 생기므로, 계속 고민을 지속했습니다.
### 생성 자체는 Enum에 맞기고, 각각의 싱글턴을 유지하면?
Enum을 통해 해당 이벤트의 실행 기간(이벤트 시작일, 종료일)을 지정하고, 각 이벤트의 인스턴스만 얻어옵니다. 이벤트 기간은 각 이벤트마다 필수적으로 지닐, 혹은 항시 유지라 하더라도 기간을 굉장히 넓게 잡으면 되기 때문에 최대한의 추상화를 통한 공통 인자입니다.
이벤트들은 본인의 이벤트에 대한 행동을 각각의 클래스에서 구현하되, 시작일과 종료일을 기입하기 위해선 Enum에 작성해야 합니다.
메인에서는 해당 Enum의 이벤트 모음 메서드를 동작시키고, Enum의 객체들이 생성되며 인스턴스를 얻어옵니다.
해당하는 방법이 이벤트를 강제로 생성하는 코드보다 오히려 더 깔끔하고, 프로그래머가 실수할 여지를 많이 남기지 않는다 생각했습니다.
(Package 클래스를 통해 이벤트 패키지 내의 클래스 목록을 가져와 강제로 동작시키는 방법도 있는 것 같으나, 제대로 된 이해 없이 사용하고 싶지 않았습니다. 또한 구조적으로 동작을 강제하는 게 아닌 클래스에 함부로 접근하여 동작시키는 것이기에 조심스러웠습니다.)
## 예외 메시지
날짜 입력 중 숫자 변환 실패, 1 이상 31 이하가 아닌 값의 경우에는 `[ERROR] 유효하지 않은 날짜입니다. 다시 입력해 주세요.`가 출력되어야 합니다.
주문 시에는 메뉴 오입력, 메뉴 개수 0 이하, 메뉴 형식이 예시와 다른 경우, 메뉴가 중복된 경우에 `[ERROR] 유효하지 않은 주문입니다. 다시 입력해 주세요.`가 출력되어야 합니다.
그러나 고객에게 안내할 이벤트 주의 사항에는 총주문 금액 만원 미만 이벤트 미적용, 음료만 주문 시 주문 불가, 주문 메뉴 최대 개수 20개라는 안내가 있습니다.
총주문 만원 미만은 예시에서도 나와있듯 정상 작동하여야 하며, 나머지 둘은 재주문을 요청해야 했습니다.
그러나 셋 다 '안내할 주의 사항'이므로 예외 메시지 출력이 '유효하지 않은 주문'으로 나와서는 안된다 생각했습니다.
따라서 (예시의 출력 문구에는 없지만) 만원 이하 주문 시 이벤트 미적용이라는 안내를 띄우되 혜택 미리보기까지 넘어가고, 나머지 둘은 정확한 안내문구 출력과 더불어 재주문을 받아야 할 것이라는 결정을 했습니다. 기능 요구 사항 중 '필요하다면 주어진 문제의 내용을 통해 유추하고 스스로 판단해 구현'하라는 문구를 통해 이처럼 생각했습니다.
나머지의 예외 사항에 대해서도 정확한 메시지를 띄울 수 있다면 좋겠으나, 우선은 요구사항에 적힌 대로 동작하게끔 만들어야겠다고 생각했습니다.
즉, 주문 과정에서 예외 발생 시 다음과 같은 처리가 필요합니다.

|예외 발생 이유|발생하는 예외 타입|예외 주체|처리 방법|재시도|
|:-:|:-:|:-:|:-:|:-:|
|메뉴 오입력|메뉴가 존재하지 않음|메뉴|유효하지 않은 주문 출력|T|
|메뉴 개수 0 이하|존재할 수 없는 수량값|수량|유효하지 않은 주문 출력|T|
|입력 형식이 예시와 다름|파싱 실패|Input|유효하지 않은 주문 출력|T|
|메뉴 중복|중복된 메뉴|주문|유효하지 않은 주문 출력|T|
|총주문 금액 만원 미만|이벤트 미적용 금액|주문|이벤트 미적용 안내 출력|F|
|음료만 주문|특정 메뉴그룹만 주문|주문|음료만 주문 불가 안내 출력|T|
|주문 최대 개수 20개 초과|주문 최대 수량 초과|주문|최대 수량 초과 안내 출력|T|

유효하지 않은 주문 메시지를 출력하는 위쪽 4개의 예외는 예외 주체가 모두 다릅니다.
따라서 각각의 예외에 대해 캐치하거나, 넓은 범위로 잡아둬야 합니다.
반면 아래쪽 예외들은 모두 주문 상황에서 특별히 확인해야 하는 예외들이므로, 예외 주체가 모두 주문입니다.
총주문 금액 만원 미만인 경우에는 재시도가 발생하지 않으므로 검증을 통한 메시지를 출력하거나 비어있는 반환값을 통해 확인하거나 혹은 예외 발생 시 무시하는 방법으로 진행되어야 합니다.

이를 위해 상속을 통한 예외의 구분을 하기로 했습니다.

|추상 예외 타입|특징|예시|
|:-:|:-:|:-:|
|치명적인 예외|프로그래밍적인 논리가 맞지 않거나 프로그래머의 실수로 강제종료되어야 하는 경우|메뉴의 금액을 음수로 입력|
|처리 가능한 예외|입력으로 인한 예외이나 단편적인 메시지를 출력해야 하며 재시도가 필요한 경우|메뉴가 존재하지 않음|
|안내 예외|애플리케이션에서 사용자에게 특별한 사항을 알려줘야 하는 경우|주문 최대 수량 초과|
금액은 현재 사용자의 입력으로 생성 또는 변경할 수 있는 부분이 아니기에, 프로그래머가 코드를 잘못 기입한 경우 해당 사항을 짚어주며 애플리케이션의 실행을 막아야 하므로 치명적인 예외로 설정하였습니다.

처리 가능한 예외가 발생한 경우, 해당 예외가 무엇이든 동일한 메시지가 출력되어야 합니다.
날짜 입력 시 파싱 실패 혹은 날짜 범위가 무엇이냐에 따라 유효하지 않은 날짜 메시지를, 주문 시 여러 상황에 대해 유효하지 않은 주문을 출력해야 합니다.
따라서 처리 가능한 예외일 때는 해당 예외가 무엇이냐보다 어떠한 과정인가가 더 중요합니다.
따라서 예외 메시지들은 각각이 올바른 형태로 지니고 있으나, 처리 가능한 예외일 때는 발생한 예외를 무시하고 과정에 대한 메시지를 던져야 한다고 판단했습니다.

## 이벤트, 빌더 패턴은 어떨까
여러 조건에 따라 증정, 할인, 혹은 둘 다 수행되어야 하는 이벤트를 위해 싱글턴을 도입하여 코드를 작성하고 있었습니다.
그러나 추후 이벤트의 종류가 무한히 많아질 수 있고, 이를 모두 싱글턴으로 유지하다간 코드의 유지보수가 상당히 어려워질 거라는 생각이 들었습니다.
따라서 여러 조건을 기입해 알맞는 이벤트를 생성할 수 있도록 빌더 패턴의 도입을 고민하였습니다.
그 중에서도 일반적인 빌더가 아닌, 스프링 시큐리티처럼 `.and()`를 통한 연계적인 빌더를 구축하고 싶다는 생각이 들어 공식문서와 [해당 블로그 글](https://ktae23.tistory.com/248)을 참조하였습니다.
파고들면 파고들수록 어려웠으나, 제가 만들고자 하는 형태의 핵심적인 내용을 알 수 있었습니다.
- `and()`는 상위의 빌더를 반환한다.
- 상위의 빌더는 하위 빌더마다의 특정 메서드를 지닌다.
- 상위의 빌더를 통해 하위 빌더를 생성하고, 상위 빌더는 하위 빌더의 빌드 구현체 혹은 하위 빌드 자체를 내부적으로 지닌다.

시큐리티처럼 제네릭을 사용해보고자 했으나 우선 현재 주어진 내용만으로 먼저 구상하고, 추후 확장성을 고려해보기로 했습니다. 한번에 너무 많은 것을 고려했다간 오버 엔지니어링이 되어 복잡도가 증가하고 막상 다른 것들을 완성할 절대적 시간이 부족하여 지난 과제처럼 마지막에 서둘러 마감하고 싶지 않았기 때문입니다.

```java
public List<Promotion> promotions =  
        new ChristmasPromotionsBuilder()  
                .init("크리스마스 디데이 할인", "2023-12-01", "2023-12-31")  
                        .discountIncrease("2023-12-01", 1_000, 100)  
                        .and()  
                .and()  
        .build();
```

그러나 막상 최소한의 동작만을 하는 빌더를 만들어보니, 위와 같은 형태로 이벤트들을 반환하게 되었습니다.
손쉽게 이벤트를 만들고 동작시킬 수는 있으나, 내부 구조를 완벽히 이해하지 못했다면 사용하기 힘들어 보였습니다.
더군다나 필드가 아닌 동작 자체를 기준으로 값을 적다 보니 내부 로직이 복잡하면 복잡해질수록 빌더 역시 엄청나게 많은 정보들을 지니고 있어야 하며, 오남용 가능성이 많아진다는 것을 깨달을 수 있었습니다.
차라리 기존에 계획했던 방식이 확장에는 더 유리한 구조를 지니고 있을 것 같았습니다.
아니면 온전히 함수형만을 사용하여, 빌더와 함수형을 합친 구조라면 더 좋을 거라는 생각을 했으나 이 또한 명확성이 떨어진다고 판단했습니다.
특히, 로직의 동작을 어떻게 테스트할 지 의문이었습니다. 함수형 자체가 비즈니스 로직인데, 이를 테스트하기 위해선 본 코드의 함수형을 가져온 후 파라미터를 넣으며 값을 테스트해야 했습니다.
private 필드로 작성되어 있을 시, 리플렉션을 사용하여 가져올 수는 있으나 해당하는 방식이 옳지 않다고 생각했습니다.
애초에 빌더 패턴이 상태가 여럿 있는 객체를 만들 때 사용되는 패턴이다 보니, 해당 흐름에서는 적절치 않았다고 생각합니다.
다만 `and()`를 사용해보는 빌더는 어떤 구조인지, 시큐리티가 어떻게 내부적으로 복잡한 상태를 구조화하는지 조금은 공부할 수 있어 좋았습니다.

## 할인 방법에 따른 분류
할인 방법은 메뉴당 할인과 총주문 금액에서 할인이 있습니다.
처음에 이 둘을 동일선상에서 보았으나, 할인 총계를 내기 직전 따로 봐야 한다는 생각이 들었습니다.
### 메뉴당 할인
말 그대로, 할인을 거칠 때 각 메뉴 1개당 원가를 깎아주어야 합니다.
만약 1,000원짜리 음료 메뉴가 생겼다면, 2,023원을 깎아주었을 때 0원이 되어야 합니다. 값이 음수가 되어버리면 오히려 음식값을 역으로 줘야 하는 것처럼 되어버릴 수도 있기 때문입니다.
### 총주문 금액에서 할인
이는 앞선 할인이 끝난 이후, 마지막에 현재 금액을 확인하고 금액을 할인해야 합니다. 마찬가지로 총주문 금액보다 할인 금액이 더 큰 경우에는 0원으로 찍혀야 할 것입니다.
### 문제가 될 수 있는 상황 - 25일에 아이스크림 1개를 주문할 경우
> 현재 10,000원 이상을 주문해야만 이벤트가 적용되어 해당 과정은 틀린 예시입니다. 다만 추후 최소 적용금액 또는 할인금액에 변동이 생겼을 때 이와 같은 문제가 일어날 수 있기에 작성했습니다.

25일에 적용되는 할인은 크리스마스 디데이 할인, 평일 할인, 특별 할인입니다.
아이스크림 1개의 가격은 5,000원이며 아래와 같이 할인이 들어가야 합니다.

|이벤트|할인 가격|할인 후 가격|
|:-:|:-:|:-:|
|평일 할인(메뉴당 할인)|2,023|2,977|
|특별 할인(총주문 금액에서 할인)|1,000|1,977|
|크리스마스 디데이 할인(총주문 금액에서 할인)|3,400|0|

혹 순서가 바뀐다 한들

|이벤트|할인 가격|할인 후 가격|
|:-:|:-:|:-:|
|평일 할인(메뉴당 할인)|2,023|2,977|
|크리스마스 디데이 할인(총주문 금액에서 할인)|3,400|0|
|특별 할인(총주문 금액에서 할인)|1,000|0|

위와 같이 결국엔 0원이 나와야 합니다.

이처럼 주문 금액보다 할인 금액이 더 크게 나오는 경우가 있을 수 있습니다.
물론 위에 작성했듯 현재로서는 일어나지 않은 문제입니다. 10,000원 이상 주문해야 이벤트가 적용되기 때문입니다.
다만 이러한 이벤트 적용 조건이 곧 로직의 안전성을 뜻하는 건 아니라고 생각했습니다. 할인 가격이 이벤트당 3,000~4,000원을 넘어가게 되면 충분히 문제가 생길 수 있는 구조입니다. 아이스크림 2개를 시켰을 때, 특별 할인 가격이 지금보다 조금만 더 높았어도 문제가 생겼을 것입니다(아이스크림 2개 평일 할인 후 5,954원 - 크리스마스 디데이 할인으로 2,554원 - 특별 할인으로 1,554원. 현재만 해도 무려 84.46%의 할인률을 보여줍니다).
### 어떤 방식으로 보여줄 것인가?
이벤트 목표 중 `중복된 할인과 증정을 허용해서, 고객들이 혜택을 많이 받는다는 것을 체감할 수 있게 하는 것`이 있습니다. 내부적으로 음수 값 할인은 막더라도, 혜택 내역과 총혜택 금액에는 할인값을 그대로 보여주어 '그만큼 많이 할인받아서 공짜로 물건을 살 수 있었구나'라는 것을 보여줘야 할 것입니다.
### 실제 상황이었다면?
공짜로 물건을 구매할 수 있다는 것은 많은 사용자가 악용할 수 있다는 뜻입니다.
그러나 오히려 결제 금액이 음수로 나와 더 큰 문제를 일으킬 상황을 미리 막는다는 게 현재로서는 중요하다 생각하고, 기능 요구 사항에서 볼 수 있듯 비즈니스팀의 사내 이벤트이므로 외부 인원들로 인한 회사의 큰 손실(예를 들면 할인 코드를 악용한 아마존 공짜 물품 주문이라던가)은 없을 것이라 생각했습니다.
물론 그 전에 앞서, 이러한 고려 사항들에 대해 메일을 통한 소통(혹은 메일 발송일을 기준으로 1주일 뒤에 예정된 개발 회의에서의 소통)으로 맞춰나가야 할 것이라 생각합니다.
## 이벤트 통계 클래스(promotionStatistics)가 커진 이유
처음 계획은 통계 클래스가 그렇게 크지 않게끔 하려 했습니다. 그러나 각 이벤트마다의 결과를 집계하다 보니 너무나도 커졌습니다.
현재 통계 클래스는 이러한 형태로 작동합니다.

|혜택\\이벤트|크리스마스 디데이 할인|평일 할인|주말 할인|특별 할인|증정 이벤트|
|:-:|:-:|:-:|:-:|:-:|:-:|
|증정 이벤트|||||O|
|메뉴 할인||O|O||
|총액 할인|O|||O||

주문 날짜와 주문 목록을 통해 위와 같은 데이터들을 만들고, 세로 줄마다의 합을 구해 각각 이벤트의 총 혜택을 계산합니다(이는 추후 하나의 이벤트에서 여러 혜택을 증정할 수 있음을 가정하여 만들었습니다).
또한 가로 줄마다의 합을 구해 모든 증정품, 모든 메뉴 할인, 모든 총액 할인을 계산합니다.
이 때 이미 할인 관련한 데이터가 생성되는데, 이러한 흐름을 다른 클래스(할인을 담당하는 클래스)에서 가져가려 했으나 이미 완성된 데이터를 끌어오는 형태였기에 의미가 없다고 판단했습니다.
할인의 흐름을 따로 가져가기 위해 강제로 데이터를 분해시켜도 이벤트의 결과에 따라 혜택을 구할 수 있기 때문에 오히려 코드 파악이 힘들어지는 형태 및 비효율적인 구성을 하게 되는 듯 했습니다.
하루 넘게 이 상황을 어떻게 타파해야 할 지 고민하다가, 결국 지금과 같은 구조를 만들게 되었습니다.
# 느낀 점
지금 생각하고 있는 구조가 좋은 건지, 나쁜 건지 알 수 없다는 게 마음에 걸렸습니다. 다른 사람들과 이야기하며 생각을 나누고 싶었습니다.